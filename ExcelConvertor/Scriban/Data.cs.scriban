// <auto-generated>
// This file was generated by EnumGenerator.
// Do not edit manually.

#if !SERVER
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
#endif

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.IO.Compression;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;


namespace {{ namespace }}
{
    /// <summary>
    /// in 매개변수를 받는 델리게이트 정의
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="item"></param>
    /// <returns></returns>
    public delegate bool RefPredicate<T>(in T item);

    {{~ # schemas는 CodeGenViewModel의 Schemas 속성 ~}}
    {{~ for item in schemas ~}}
    /// <summary>
    /// Schema: {{ item.schema.table }}.json
    /// </summary>
    public readonly struct {{ item.struct_name }}
    {
        {{~ # 필드가 하나라도 있는 경우에만 이 블록을 생성 ~}}
        {{~ if item.sortable_fields.size > 0 ~}}
        // --- 메모리 레이아웃을 고려해서 정렬된 필드 ---
        {{~ for field in item.sortable_fields ~}}
        public readonly {{ field.type }} {{ field.name }};
        {{~ end ~}}
        {{~ end ~}}

        {{~ # 문자열 필드가 하나라도 있는 경우에만 이 블록들을 생성 ~}}
        {{~ if item.string_fields.size > 0 ~}}
        // --- 문자열 속성 ---
        {{~ for field in item.string_fields ~}}
        public string {{ field.key }} => {{ manager_name }}.Instance.StringTable.GetString(_{{ field.key | string.downcase }}Index);
        {{~ end ~}}
        {{~ end ~}}
        
        // 객체 유효성 검사
        public bool IsValid => {{ item.primary_key_name }} != default;

        {{~ # 생성자 추가 ~}}
        public {{ item.struct_name }}(
            {{~ for field in item.value_fields ~}}
            {{ field.value.type }} {{ field.key | string.downcase }}{{ if !for.last || item.string_fields.size > 0 }}, {{ end }}
            {{~ end ~}}
            {{~ for field in item.string_fields ~}}
            int {{ field.key | string.downcase }}Index{{ if !for.last }}, {{ end }}
            {{~ end ~}}
        )
        {
            {{~ for field in item.value_fields ~}}
            this.{{ field.key }} = {{ field.key | string.downcase }};
            {{~ end ~}}
            {{~ for field in item.string_fields ~}}
            this._{{ field.key | string.downcase }}Index = {{ field.key | string.downcase }}Index;
            {{~ end ~}}
        }
    }

    /// <summary>
    /// Data table for {{ item.schema.table }}.
    /// </summary>
    public class {{ item.table_class_name }}
    {
        private readonly {{ item.struct_name }}[] _dataArray;
        private readonly Dictionary<{{ item.primary_key_type }}, int> _keyToIndexMap;
        private readonly static {{ item.struct_name }} _defaultInstance = new {{ item.struct_name }}();

        public {{ item.table_class_name }}(int capacity)
        {
            _dataArray = new {{ item.struct_name }}[capacity];
            _keyToIndexMap = new Dictionary<{{ item.primary_key_type }}, int>(capacity);
        }

        public ref readonly {{ item.struct_name }} Get({{ item.primary_key_type }} {{ item.primary_key_parameter_name }})
        {
            if (_keyToIndexMap.TryGetValue({{ item.primary_key_parameter_name }}, out var index))
            {
                return ref _dataArray[index];
            }
        
            return ref _defaultInstance;
        }

        public ref readonly {{ item.struct_name }} FirstOrDefault(RefPredicate<{{ item.struct_name }}> predicate)
        {
            foreach (ref readonly var data in _dataArray.AsSpan())
            {
                if (predicate(data))
                {
                    return ref data;
                }
            }
            return ref _defaultInstance;
        }

    
        public ReadOnlySpan<{{ item.struct_name }}> GetAll() => _dataArray.AsSpan();

        public void Add(in {{ item.struct_name }} data)
        {
            var index = _keyToIndexMap.Count;
            _dataArray[index] = data;
            _keyToIndexMap.Add(data.{{ item.primary_key_name }}, index);
        }
    }

    /// <summary>
    /// Data loader for {{ item.schema.table }}.
    /// </summary>
    public static class {{ item.loader_class_name }}
    {
        private class Loader : DataTableLoaderBase<{{ item.struct_name }}, {{ item.table_class_name }}>
        {
            protected override {{ item.table_class_name }} CreateTable(int capacity)
                => new {{ item.table_class_name }}(capacity);

            protected override void AddToTable({{ item.table_class_name }} table, in {{ item.struct_name }} data) 
                => table.Add(in data);

            protected override {{ item.struct_name }} LoadRecord(BinaryReader reader, int rowLength)
            {
                long recordEndPosition = reader.BaseStream.Position + rowLength;
                // 필드 변수 선언 및 초기화
                {{~ for field in item.all_fields ~}}
                {{ if field.is_string }}{{ "int" }}{{ else }}{{ field.clean_type }}{{ end }} {{ if field.is_string }}{{ field.camel_case_name }}Index{{ else }}{{ field.camel_case_name }}{{ end }} = default;
                {{~ end ~}}
                while (reader.BaseStream.Position < recordEndPosition)
                {
                    int fieldId = reader.ReadInt32();
                    int length = reader.ReadInt32();
                    switch (fieldId)
                    {
                        {{~ for field in item.all_fields ~}}
                        case {{ field.id }}: // {{ field.name }}
                            {{ field.read_statement }}
                            break;
                        {{~ end ~}}
                        default:
                            // 알 수 없는 필드 ID인 경우, 해당 길이만큼 건너뛴다.
                            reader.BaseStream.Seek(length, SeekOrigin.Current);
                            break;
                    }
                }
                return new {{ item.struct_name }}(
                    {{~ for field in item.all_fields ~}}
                    {{ if field.is_string }}{{ field.name | string.downcase }}Index{{ else }}{{ field.name | string.downcase }}{{ end }}: {{ if field.is_string }}{{ field.camel_case_name }}Index{{ else }}{{ field.camel_case_name }}{{ end }}{{ if !for.last }}, {{ end }}
                    {{~ end ~}}
                );
            }
       }

       public static bool TryLoad(string filePath, byte[] key, [NotNullWhen(true)] out {{ item.table_class_name }} dataTable)
            => new Loader().TryLoad(filePath, key, out dataTable);
    }
    {{~ # 마지막 항목이 아닐 경우에만 개행을 추가하여 클래스 간 간격을 조정 ~}}
    {{~ if !for.last ~}}

    {{~ end ~}}
    {{~ end ~}}

    #region 바이너리 로드 공통 로직
    internal static class EncryptedDataTableReader
    {
        internal static byte[] DecryptAndDecompress(string filePath, byte[] key)
        {
            using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
            using var fileReader = new BinaryReader(fileStream, Encoding.UTF8);

            // 헤더 읽기
            var aad = fileReader.ReadBytes(5);
            var nonce = fileReader.ReadBytes(12);
            var tag = fileReader.ReadBytes(16);
            var cipherText = fileReader.ReadBytes((int)(fileStream.Length - 33)); // 5+12+16

            // 검증
            ValidateHeader(aad);

            // 복호화
            byte[] plainText = Decrypt(cipherText, key, nonce, tag, aad);

            // 압축 해제
            return Decompress(plainText);
        }

        private static void ValidateHeader(byte[] aad)
        {
            Span<byte> expectedMagic = stackalloc byte[] { 0x45, 0x58, 0x43, 0x42 }; // EXCB
            if (!aad.AsSpan(0, 4).SequenceEqual(expectedMagic))
                throw new InvalidDataException("Invalid file format - magic number mismatch");

            byte version = aad[4];
            if (version != 1)
                throw new NotSupportedException($"Unsupported file version: {version}");
        }

        private static byte[] Decrypt(byte[] cipherText, byte[] key, byte[] nonce, byte[] tag, byte[] aad)
        {
#if SERVER
            byte[] plainText = new byte[cipherText.Length];
            using var aesGcm = new AesGcm(key, tag.Length);
            aesGcm.Decrypt(nonce, cipherText, tag, plainText, aad);
            return plainText;
#else
            var cipher = new GcmBlockCipher(new AesEngine());
            var parameters = new AeadParameters(new KeyParameter(key), tag.Length * 8, nonce, aad);
            cipher.Init(false, parameters);

            byte[] cipherAndTag = new byte[cipherText.Length + tag.Length];
            Buffer.BlockCopy(cipherText, 0, cipherAndTag, 0, cipherText.Length);
            Buffer.BlockCopy(tag, 0, cipherAndTag, cipherText.Length, tag.Length);

            byte[] plainText = new byte[cipher.GetOutputSize(cipherAndTag.Length)];
            int len = cipher.ProcessBytes(cipherAndTag, 0, cipherAndTag.Length, plainText, 0);
            cipher.DoFinal(plainText, len);
            return plainText;
#endif
        }

        private static byte[] Decompress(byte[] compressedData)
        {
            using var compressedStream = new MemoryStream(compressedData);
            using var gzipStream = new GZipStream(compressedStream, CompressionMode.Decompress);
            using var resultStream = new MemoryStream();
            gzipStream.CopyTo(resultStream);
            return resultStream.ToArray();
        }
    }

    public abstract class DataTableLoaderBase<TData, TTable>
        where TData : struct
        where TTable : class
    {
        protected abstract TTable CreateTable(int capacity);
        protected abstract TData LoadRecord(BinaryReader reader, int rowLength);
        protected abstract void AddToTable(TTable table, in TData data);

        public bool TryLoad(string filePath, byte[] key, [NotNullWhen(true)] out TTable dataTable)
        {
            dataTable = null;
            try
            {
                var plainText = EncryptedDataTableReader.DecryptAndDecompress(filePath, key);
                using var stream = new MemoryStream(plainText);
                using var reader = new BinaryReader(stream, Encoding.UTF8);

                int rowCount = reader.ReadInt32();
                dataTable = CreateTable(rowCount);

                for (int i = 0; i < rowCount; ++i)
                {
                    int recordSize = reader.ReadInt32();
                    var data = LoadRecord(reader, recordSize);
                    AddToTable(dataTable, in data);
                }
                return true;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load data table from {filePath}. Reason: {ex.Message}");
                return false;
            }
        }
    }
    #endregion
}