// <auto-generated>
// This file was generated by EnumGenerator.
// Do not edit manually.

#if !SERVER
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
#endif

using System;
using System.IO;
using System.IO.Compression;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

namespace {{ namespace }}
{
    #region Encryption Key Providers
    /// <summary>
    /// 환경별 암호화 키 제공자
    /// </summary>
    public interface IEncryptionKeyProvider
    {
        byte[] GetKey();
        string GetEnvironment();
    }

    /// <summary>
    /// 로컬 개발 환경용 - 고정된 개발 키 사용
    /// </summary>
    public class DevelopmentKeyProvider : IEncryptionKeyProvider
    {
        private static readonly byte[] DevKey = Convert.FromBase64String("ui6yt/8nILrWcg+xGVWliahscs6jJ6j6fDBo2gpZklY=");

        public byte[] GetKey() => DevKey;
        public string GetEnvironment() => "Development";
    }

    /// <summary>
    /// 프로덕션 환경용 - 외부에서 주입받은 키 사용
    /// </summary>
    public class ProductionKeyProvider : IEncryptionKeyProvider
    {
        private readonly byte[] _key;

        public ProductionKeyProvider(string base64Key)
        {
            _key = Convert.FromBase64String(base64Key);

            if (_key.Length != 32)
            {
                throw new ArgumentException("Encryption key must be 32 bytes (256 bits) long.");
            }
        }

        public byte[] GetKey() => _key;
        public string GetEnvironment() => "Production";
    }
    #endregion

    /// <summary>
    /// 문자열 테이블 관리 클래스
    /// </summary>
    public class {{ string_table_name }}
    {
        // 메모리 로드 시 할당..
        private readonly string[] _strings;

        public {{ string_table_name }}(string[] strings)
        {
            _strings = strings;
        }

        public string GetString(int index)
        {
            return _strings[index];
        }

        public static {{ string_table_name }} Load(string path, byte[] key)
        {
            try
            {
                var plainData = EncryptedDataTableReader.DecryptAndDecompress(path, key);
                using var decompressedStream = new MemoryStream(plainData);
                using var reader = new BinaryReader(decompressedStream, Encoding.UTF8);

                // 문자열 수 읽기
                int stringCount = reader.ReadInt32();

                string[] strings = new string[stringCount];

                for (int i = 0; i < stringCount; ++i)
                {
                    // 문자열 길이 읽기
                    int strLength = reader.ReadInt32();
                    // 문자열 데이터 읽기
                    byte[] strBytes = reader.ReadBytes(strLength);
                    strings[i] = Encoding.UTF8.GetString(strBytes);
                }

                return new {{ string_table_name }}(strings);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading string table from {path}: {ex.Message}");
                return null;
            }
        }
    }


    /// <summary>
    /// 테이블 접근 전역 객체
    /// </summary>
    public partial class {{ manager_name }}
    {
        // 싱글턴 객체를 만든다.
        private static {{ manager_name }} _instance = new {{ manager_name }}();

        public static {{ manager_name }} Instance => _instance;

        public int Revision { get; private set; }

        public {{ string_table_name }} StringTable { get; private set; } = null!;

        private {{ manager_name }}() { }
        static {{ manager_name }}()
        {
            _instance = new {{ manager_name }}();
        }

        public bool Init(string dataDir, int revision, IEncryptionKeyProvider encryptionKeyProvider)
        {
            var tempKey = encryptionKeyProvider.GetKey();

            var stringTable = {{ string_table_name }}.Load(Path.Combine(dataDir, "{{ string_table_name }}.bytes"), tempKey);
            if (stringTable == null)
            {
                return false;
            }

            StringTable = stringTable;

            if (false == LoadBinaryData(dataDir, tempKey))
            {
                return false;
            }

            if (false == InitDependencyData())
            {
                return false;
            }

            Revision = revision;

            return true;
        }


        public static bool Replace(string dataDir, int revision, IEncryptionKeyProvider encryptionKeyProvider)
        {
            var newOne = new {{ manager_name }}();
            if (false == newOne.Init(dataDir, revision, encryptionKeyProvider))
                return false;

            Interlocked.Exchange(ref _instance, newOne);

            return true;
        }


        public T GetConstant<T>(Constant key)
        {
            ref readonly var foundData = ref Constant.Get((int)key);

            if (foundData.IsValid)
            {
                return (T)Convert.ChangeType(foundData.Value, typeof(T));
            }
            else
            {
                return default;
            }
        }
    }
}